"""
Extractor Factory Module

This module provides a factory function to get the appropriate extractor
based on the type of CAD element. It also provides a function to extract 
data from components (including elements contained withing it, such as 
sketches, featurs, and BRep bodies.

Functions:
    - get_extractor: Returns the appropriate extractor for the given 
      element.
    - extract_data: Extracts data from the given element using the 
      appropriate extractor.
    - extract_component_data: Extracts data from components, sketches, 
      features, and BRep bodies.
"""
import logging
from typing import Tuple, List, Dict

from adsk.core import Base
import adsk.fusion
from adsk.fusion import Sketch, Feature, BRepBody, Component # TODO standardise adsk impors
from .base_extractor import BaseExtractor
from .sketch_extractor import SketchExtractor
from .feature_extractor import FeatureExtractor
from .brep_extractor import BRepExtractor
from ..utils.logger import Logger

__all__ = ['get_extractor', 'extract_data', 'extract_component_data']

EXTRACTORS = {
    'adsk::fusion::Sketch': SketchExtractor,
    'adsk::fusion::ExtrudeFeature': FeatureExtractor, 
    'adsk::fusion::BRepBody': BRepExtractor, 
}
# TODO generalise for different features

def get_extractor(element: Base) -> BaseExtractor:
    """Get the appropriate extractor for the given CAD element.

    Args:
        element (Base): The CAD element.

    Returns:
        BaseExtractor: The appropriate extractor for the element.
    """
    extractor_class = EXTRACTORS.get(element.objectType, BaseExtractor)
    return extractor_class(element)


def extract_data(element: Base) -> dict:
    """Extracts data from the given element using the appropriate extractor.

    Args:
        element (Base): The CAD element.

    Returns:
        dict: The extracted data.
    """
    try:
        Logger.info(f"Processing element: {element.classType()}")
        Extractor = get_extractor(element)
        extracted_info = Extractor.extract_info()
        return {
            "type": element.classType(),
            "properties": extracted_info
        }
    except Exception as e:
        Logger.error(f"Error in extract_data: {str(e)}")
        return None

def extract_component_data(design: adsk.fusion.Design, Logger: logging.Logger = None) -> Tuple[List[Dict], List[Dict]]:
    """
    Extracs data from the components, and their children sketches, features and
    BRep bodies in the design.

    Args:
        desing: The Fusion360 design object.
        Logger: The logger object for logging messages and errors.

    Returns:
        tuple: A tuple containing the list of nodes and relationships.
    """
    nodes = []
    relationships = []
    # component_id_map = {}
    # id_token_map = {} # TODO: use this to avoid duplications

    def extract_and_append(entity, parent_id, rel_type):
        """Helper function to extract data and append nodes and relationships."""
        try:
            extracted_info = extract_data(entity)
            if extracted_info:
                nodes.append(extracted_info)
                entity_id = extracted_info['properties']['id_token']
                relationships.append({
                    "from_id": parent_id,
                    "to_id": entity_id,
                    "rel_type": rel_type
                })
                return entity_id
        except Exception as e:
            if Logger:
                Logger.error(f"Error extracting and appending data for {entity}: {str(e)}")
        return None
    
    comp = design.rootComponent
    if comp:
        Logger.info('Starting component Extraction')
        Logger.info(f'Extracting component: {comp.name}')

        # Extract compnent node
        component_info = extract_data(comp)
        if component_info:
            nodes.append(component_info)
            component_id = component_info['properties']['id_token']

        # Extract Sketches
        for sketch in comp.sketches:
            _ = extract_and_append(sketch, component_id, "CONTAINS")

        # Extract Features 
        for feat in comp.features:
            feature_id = extract_and_append(feat, component_id, "CONTAINS")

            # Extraact BRep bodies generated by this feature
            if feature_id and hasattr(feat, 'bodies'):
                for body in feat.bodies:
                    _ = extract_and_append(body, feature_id, "CONTAINS")

        for body in comp.bRepBodies:
            _ = extract_and_append(body, component_id, "CONTAINS")

    return nodes, relationships